
  const gameLoop = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctxMaybe = canvas.getContext("2d")
    if (!ctxMaybe) { animationRef.current = requestAnimationFrame(gameLoop); return }
    const ctx = ctxMaybe
    // Draw background gradient
    const gradient = ctx.createLinearGradient(0, 0, 0, CONST.CANVAS_HEIGHT)
    gradient.addColorStop(0, "#87CEEB")
    gradient.addColorStop(1, "#F0E68C")
    ctx.fillStyle = gradient
    ctx.fillRect(0, 0, CONST.CANVAS_WIDTH, CONST.CANVAS_HEIGHT)

    // Draw ground
    ctx.fillStyle = "#8B4513"
    ctx.fillRect(0, CONST.GROUND_Y, CONST.CANVAS_WIDTH, CONST.CANVAS_HEIGHT - CONST.GROUND_Y)

    // Draw grass
    ctx.fillStyle = "#228B22"
    for (let i = 0; i < CONST.CANVAS_WIDTH; i += 5) {
      const height = 3 + Math.sin(i * 0.1) * 2
      ctx.fillRect(i, CONST.GROUND_Y - height, 3, height)
    }

    // Ball physics and collision
    ballsRef.current.forEach((ball) => {
      if (!ball.active) return

      ball.x += ball.vx
      ball.y += ball.vy
      ball.vy += CONST.GRAVITY

      // Ground collision
      if (ball.y + ball.radius > CONST.GROUND_Y) {
        ball.y = CONST.GROUND_Y - ball.radius
        ball.vy *= -CONST.BOUNCE_DAMPING
        ball.vx *= CONST.FRICTION

        if (Math.abs(ball.vy) > CONST.BOUNCE_VELOCITY_THRESHOLD) {
          Audio.playGroundBounceSound(audioContextRef)
        }

        if (Math.abs(ball.vy) < CONST.BOUNCE_VELOCITY_THRESHOLD && Math.abs(ball.vx) < 1) {
          ball.vy = 0
          ball.vx *= 0.8
        }
      }

      // Wall collision
      if (ball.x - ball.radius < 0 || ball.x + ball.radius > CONST.CANVAS_WIDTH) {
        ball.vx *= -CONST.BOUNCE_DAMPING
        ball.x = ball.x - ball.radius < 0 ? ball.radius : CONST.CANVAS_WIDTH - ball.radius
      }

      // Laser creation for laser balls
      if (
        ball.type === "laser" &&
        ball.y < CONST.LASER_CREATION_HEIGHT &&
        ball.shotTime &&
        Date.now() - ball.shotTime >= CONST.LASER_CREATION_DELAY_MS &&
        lasersRef.current.filter((l) => l.ballId === ball.id).length === 0
      ) {
        dlog("[v0] Creating lasers for laser ball")
        Audio.playLaserShootSound(audioContextRef)

        const activeTowers = towersRef.current.filter((t) => !t.destroyed)
        const midIndex = Math.floor(activeTowers.length / 2)
        const targetableTowers = activeTowers.slice(midIndex)

        for (let i = 0; i < CONST.LASER_COUNT; i++) {
          if (targetableTowers.length > 0) {
            const randomTower = targetableTowers[Math.floor(Math.random() * targetableTowers.length)]
            const targetX = randomTower.x + randomTower.width / 2
            const targetY = randomTower.y + randomTower.height / 2

            const dx = targetX - ball.x
            const dy = targetY - ball.y
            const angle = Math.atan2(dy, dx)

            const randomLength =
              CONST.LASER_MIN_LENGTH + Math.random() * (CONST.LASER_MAX_LENGTH - CONST.LASER_MIN_LENGTH)

            lasersRef.current.push({
              x: ball.x,
              y: ball.y,
              angle: angle,
              length: randomLength,
              active: true,
              hitCount: 0,
