using System;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Models;
using Beamable.Api.Autogenerated.Content;
using Beamable.Common;
using Beamable.Server.Content;
using Beamable.StellarFederation.Features.Minting.Json;
using Beamable.StellarFederation.Features.Transactions.Storage;
using TaskExtensions = Beamable.StellarFederation.Extensions.TaskExtensions;

namespace Beamable.StellarFederation.Features.Minting;

public class MetadataService : IService
{
    private readonly IContentApi _contentApi;
    private readonly ContentService _contentService;
    private readonly MintCollection _mintCollection;
    private readonly HttpClient _httpClient = new();

    private readonly JsonSerializerOptions _jsonSerializerOptions = new()
    {
        Converters = { new ObjectAsPrimitiveConverter() }
    };

    public MetadataService(IContentApi contentApi, ContentService contentService, MintCollection mintCollection)
    {
        _contentApi = contentApi;
        _contentService = contentService;
        _mintCollection = mintCollection;
    }

    public async Task<string> GetBaseUri(string id)
    {
        var binaryResponse = await _contentApi.PostBinary(new SaveBinaryRequest
        {
            binary =
            [
                new BinaryDefinition
                {
                    id = id,
                    checksum = "01",
                    uploadContentType = "plain/text"
                }
            ]
        });

        var uri = new Uri(binaryResponse.binary.First().uri);

        // Remove the last segment
        var segments = uri.Segments.Take(uri.Segments.Length - 1);
        var baseUriString = $"{uri.Scheme}://{uri.Host}{string.Concat(segments)}";
        return baseUriString;
    }

    public async Task<string> SaveMetadata(NftExternalMetadata metadata)
    {
        var uriString = await StoreExternalMetadata(metadata);
        BeamableLogger.Log("Metadata saved at {uri}", uriString);
        var uri = new Uri(uriString);
        return uri.Segments.Last();
    }

    private async Task<string> StoreExternalMetadata(NftExternalMetadata metadata)
    {
        var metadataJsonString = JsonSerializer.Serialize(metadata, _jsonSerializerOptions);
        return await StoreExternalMetadata(metadataJsonString);
    }

    private async Task<string> StoreExternalMetadata(string metadataJson)
    {
        var metadataPayload = Encoding.UTF8.GetBytes(metadataJson);
        var md5Bytes = MD5.HashData(metadataPayload);
        var payloadChecksum = BitConverter.ToString(md5Bytes).Replace("-", "");

        var saveBinaryResponse = await TaskExtensions.WithRetry(
            async () => await _contentApi.PostBinary(new SaveBinaryRequest
            {
                binary =
                [
                    new BinaryDefinition
                    {
                        id = "metadata",
                        checksum = payloadChecksum,
                        uploadContentType = "application/json"
                    }
                ]
            }),
            5,
            500);

        var binaryResponse = saveBinaryResponse.binary.First();
        var signedUrl = binaryResponse.uploadUri;

        var content = new ByteArrayContent(metadataPayload);
        content.Headers.ContentType = new MediaTypeHeaderValue("application/json");
        content.Headers.ContentMD5 = md5Bytes;

        var putContentResponse = await TaskExtensions.WithRetry(
            async () => await _httpClient.PutAsync(signedUrl, content),
            5,
            500);

        putContentResponse.EnsureSuccessStatusCode();
        return binaryResponse.uri;
    }
}