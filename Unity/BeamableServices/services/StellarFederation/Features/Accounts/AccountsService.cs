using System;
using System.Linq;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Accounts;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.StellarFederation.Caching;
using Beamable.StellarFederation.Features.Accounts.Models;
using Beamable.StellarFederation.Features.Accounts.Storage;
using Beamable.StellarFederation.Features.Accounts.Storage.Models;
using Beamable.StellarFederation.Features.Stellar;

namespace Beamable.StellarFederation.Features.Accounts;

public class AccountsService : IService
{
    private const string RealmAccountName = "default-account";
    private readonly VaultCollection _vaultCollection;
    private readonly Configuration _configuration;
    private readonly AccountsApi _accountsApi;
    private readonly IBeamableRequester _beamableRequester;
    private readonly StellarService _stellarService;
    private Account _cachedRealmAccount;

    public AccountsService(VaultCollection vaultCollection, Configuration configuration, AccountsApi accountsApi, IBeamableRequester beamableRequester, StellarService stellarService)
    {
        _vaultCollection = vaultCollection;
        _configuration = configuration;
        _accountsApi = accountsApi;
        _beamableRequester = beamableRequester;
        _stellarService = stellarService;
    }

    public async Task<Account> GetOrCreateAccount(string accountName)
    {
        var account = await GetAccount(accountName);
        if (!account.HasValue)
        {
            account = await CreateAccount(accountName);
            if (account is null)
            {
                BeamableLogger.LogWarning("Account already created, fetching again");
                return await GetOrCreateAccount(accountName);
            }

            BeamableLogger.Log("Saved account {accountName} -> {accountAddress}", accountName, account.Value.Address);
        }
        return account.Value;
    }

    public async ValueTask<Account> GetOrCreateRealmAccount()
    {
        if (_cachedRealmAccount != default)
            return _cachedRealmAccount;

        var account = await GetAccount(RealmAccountName);
        if (!account.HasValue)
        {
            account = await CreateAccount(RealmAccountName);
            if (!account.HasValue)
            {
                BeamableLogger.LogWarning("Account already created, fetching again");
                return await GetOrCreateRealmAccount();
            }

            BeamableLogger.Log("Saved account {accountName} -> {accountAddress}", RealmAccountName,
                account.Value.Address);
            BeamableLogger.LogWarning(
                "Please add some gas money to your account {accountAddress} to be able to pay for fees.",
                account.Value.Address);
        }
        _cachedRealmAccount = account.Value;
        return account.Value;
    }

    public async ValueTask<Account> GetOrImportRealmAccount(string privateKey)
    {
        if (_cachedRealmAccount != default)
            return _cachedRealmAccount;

        var account = await GetAccount(RealmAccountName);
        if (account is null)
        {
            account = await CreateAccount(RealmAccountName, privateKey);
            if (account is null)
            {
                BeamableLogger.LogWarning("Account already created, fetching again");
                return await GetOrImportRealmAccount(privateKey);
            }

            BeamableLogger.Log("Saved account {accountName} -> {accountAddress}", RealmAccountName,
                account.Value.Address);
            BeamableLogger.LogWarning(
                "Please add some gas money to your account {accountAddress} to be able to pay for fees.",
                account.Value.Address);
        }
        _cachedRealmAccount = account.Value;
        return account.Value;
    }

    public async ValueTask<Account?> GetRealmAccount()
    {
        if (_cachedRealmAccount != default)
            return _cachedRealmAccount;

        var account = await GetAccount(RealmAccountName);
        if (account != null)
        {
            _cachedRealmAccount = account.Value;
            return account;
        }
        BeamableLogger.LogWarning("Realm account {accountName} does not exist.", RealmAccountName);
        return null;
    }

    public async Task<Account> ImportAccount(string id, string privateKey)
    {
        var existingAccount = await GetAccount(id);
        if (existingAccount is not null)
            return existingAccount.Value;

        var account = await CreateAccount(id, privateKey);
        if (account is not null) return account.Value;
        BeamableLogger.LogWarning("Account already created, fetching again");
        return await ImportAccount(id, privateKey);
    }

    public async Task<Account?> GetAccount(string accountName)
    {
        return await GlobalCache.GetOrCreate<Account>($"account-{accountName}", async entry =>
        {
            var vault = await _vaultCollection.GetVaultByName(accountName);
            if (vault is null)
            {
                entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(1);
                return null;
            }

            var privateKey = EncryptionService.Decrypt(vault.PrivateKey, _configuration.RealmSecret);
            return new Account(vault.Name, vault.Address, privateKey);
        }, TimeSpan.FromDays(1));
    }

    private async Task<Account?> CreateAccount(string accountName)
    {
        var keys = _stellarService.CreateWallet();
        var privateKeyEncrypted = EncryptionService.Encrypt(keys.PrivateKey, _configuration.RealmSecret);
        var newAccount = new Account(accountName, keys.Address, keys.PrivateKey);

        return await _vaultCollection.TryInsertVault(new Vault(accountName, newAccount.Address, privateKeyEncrypted))
            ? newAccount
            : null;
    }

    private async Task<Account?> CreateAccount(string accountName, string privateKey)
    {
        var keys = _stellarService.ImportWallet(privateKey);
        var privateKeyEncrypted = EncryptionService.Encrypt(keys.PrivateKey, _configuration.RealmSecret);
        var newAccount = new Account(accountName, keys.Address, keys.PrivateKey);

        return await _vaultCollection.TryInsertVault(new Vault(accountName, newAccount.Address, privateKeyEncrypted))
            ? newAccount
            : null;
    }

    private async Task<string?> GetGamerTagByWalletAddress(string address)
    {
        return await _vaultCollection.GetNameByAddress(address);
    }

    public async Task<Account?> GetAccountByAddress(string address)
    {
        var name = await GetGamerTagByWalletAddress(address);
        if (!string.IsNullOrWhiteSpace(name))
            return await GetAccount(name);

        BeamableLogger.LogError($"Account for {address} not found");
        return null;
    }

    public async Task<Beamable.Api.Autogenerated.Models.Account?> SearchAccount(string query)
    {
        var searchResponse = await _accountsApi.GetSearch(1, 1, query);
        return searchResponse?.accounts.FirstOrDefault();
    }

    public async Task<long> GetGamerTag(string walletAddress)
    {
        var account = await SearchAccount(walletAddress);
        if (account is null)
        {
            BeamableLogger.LogError("Account not found for wallet {address}", walletAddress);
            return 0;
        }

        var gamerTag = account.gamerTags
            .Where(x => x.projectId == _beamableRequester.Pid)
            .Select(x => x.gamerTag)
            .FirstOrDefault();

        if (gamerTag == 0)
        {
            BeamableLogger.LogError("Can't find a gamerTag on project {pid} for account {aid}", _beamableRequester.Pid, account.id);
        }
        return gamerTag;
    }
}